# [HTTP 완벽 가이드] 2장. URL과 리소스

- 2장에서 다루게 될 주제를 바탕으로 정리한 내용이다.
    - URL 문법, 여러 URL 컴포넌트가 어떤  의미를 가지며 무엇을 수행하는지에 대하여
    - 여러 웹 클라이언트가 지원하는 상대 URL과 확장 URL 같은 단축 URL에 관하여
    - URL의 인코딩과 문자 규칙
    - 여러 인터넷 정보 시스템에 적용되는 공통 URL 스킴
    - 기존 이름은 유지하면 객체들을 다른 장소로 옮기는 것을 가능하게 해주는 URN(Uniform Resource Name)을 포함한 URL의 미래

# URL의 정의와 역할  🤷‍♂️

URL(Uniform Resource Locator)은 **인터넷의 리소스**(텍스트/이미지/동영상 같이 웹에서 사용되는 식별할 수 있는 모든 자원)를 가리키는 표준이름이다.

<aside>
💡 리소스 : 나는 기본적으로 “문서"라고 이해했다. 문서 내에 “텍스트", “이미지”, “동영상"이 모두 포함이 되기 때문이다.

</aside>

## - URL의 역할

URL을 통해 사용자는 다음과 같은 행동을 할 수 있게 된다.

- 사람과 애플리케이션이 인터넷 상의 수십억 개의 **리소스를 찾고 사용하며 공유할 수 있다.**
- 사람이 HTTP 및 다른 프로토콜을 통해 접근할 수 있다.

![사용자가 URL을 입력(요청)하면 브라우저는 적절한 프로토콜을 사용하여 메세지를 전송(응답)한다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e46bedcc-ecf3-498b-94c5-dfe5a249c855/Untitled.png)

사용자가 URL을 입력(요청)하면 브라우저는 적절한 프로토콜을 사용하여 메세지를 전송(응답)한다.

## - URL의 구조 ⭐⭐

![URL의 기본 형태와 영역 명칭](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4421aeaa-ba96-499d-baa3-562c76fc8443/Untitled.png)

URL의 기본 형태와 영역 명칭

각각의 URL 영역에서는 아래의 의미를 가진다.

- 스킴 : 웹 클라이언트가 **리소스에 어떻게 접근하는지 알려준다.** 예시로는 HTTP 프로토콜을 사용한다.

<aside>
💡 물론 **다른 프로토콜**도 사용할 수 있다. 예를 들면 mailTo, FTP(File Transfer Protocol), RTSP(Real Time Streaming Protocol) 등이 있다. 
이는 뒤의 [여러 인터넷 정보 시스템에 적용되는 URL 스킴]에서 자세하게 다룰 예정이다.

</aside>

- 호스트 : 서버의 위치를 가리킴, 웹 클라이언트가 **리소스가 어디에 호스팅 되어 있는지 알려준다.**
- 경로 : 서버에 존재하는 로컬 리소스들 중 **요청받은 리소스가 무엇인지 알려준다.**

위와 같이 대부분의 URL은 **`스킴://서버위치/경로`**의 구조로 이루어져있다.

이렇게 구성된 URL을 서버는 클라이언트로 전송하여 웹 페이지를 전송해준다.

---

# URL 문법 - 각 URL컴포넌트의 의미와 역할

URL은 인터넷 상의 모든 리소스를 찾을 수 있지만, 그 리소스들은 다른 스킴을 통해 접근하게 되면 URL 문법은 스킴에 따라 달라지게 된다.

그 말은 즉, 스킴마다 다 완전히 문법이 다르다는 뜻일까?

답은 아니다. 대부분의 URL은 일반적인 URL 문법을 따르며 다른 구조의 URL 스킴도 형태와 문법 면에서는 유사하다.

![URL스킴의 문법에서 일반적인 9가지 컴포넌트 중 가장 중요한 스킴/호스트/경로 컴포넌트를 표시를 했다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b12df22-9749-4515-b3eb-65dc54a0a034/Untitled.png)

URL스킴의 문법에서 일반적인 9가지 컴포넌트 중 가장 중요한 스킴/호스트/경로 컴포넌트를 표시를 했다.

<aside>
💡 이 9가지의 컴포넌트를 모두 가지는 URL은 거의 없다. 하지만 항상 스킴, 호스트, 경로 컴포넌트는 가지고  있다고 생각하면 된다.

</aside>

각각의 컴포넌트를 살펴보자.

| 컴포넌트 | 설명 | 기본값 |
| --- | --- | --- |
| 스킴 | 리소스를 가져오기 위해 어떤 프로토콜을 사용하여 서버에 접근해야 하는지 가리킨다. | 없음 |
| 사용자 이름 | 몇몇의 스킴은 리소스의 접근을 위해 사용자 이름을 요구한다. | anonymous |
| 비밀번호 | 사용자의 비밀번호를 가리킨다. “<사용자 이름>:<비밀번호>” 형태로 입력한다. | <이메일주소> |
| 호스트 | 리소스를 호스팅하는 서버의 호스트 명(Domain)이나 IP주소를 가리킨다. | 스킴에 따라 상이 |
| 포트 | 리소스를 호스팅하는 서버가 열어놓은 포트번호이다. 스킴마다 기본 포트를 가지고 있다.
(HTTP는 80이 기본 포트이다.) | 스킴에 따라 상이 |
| 파라미터 | 특정 스킴들에서 입력 파라미터를 기술하는 용도로 사용한다. 이름과 값을 쌍으로 가진다.
다른 피라미터나 경로의 일부와 “;”를 이용하여 구분하며 여러 개를 가질 수 있다. | 없음 |
| 경로 | 이전 컴포넌트와 “/”로 구분되어 있으며 서버 내 리소스가 서버 어디있는지 가리킨다. 
경로는 세그먼트로 나눌 수 있고 자체 컴포넌트를 가질 수 있다. | 없음 |
| 질의 | 스킴에서 애플리케이션(DB, 게시판, 검색엔진 등)에 파라미터를 전달하는데 쓰인다.
질의 컴포넌트를 작성하는데 정해진 형태는 없으며 URL의 끝에 “?”로 구분한다. | 없음 |
| 프레그먼트 | 리소스 조각이나 일부분을 가리키는 이름이다. URL의 끝에서 “#”로 구분한다. |  없음 |

- **스킴 : 사용할 프로토콜**

스킴 프로토콜은 알파벳으로 시작해야하고 URL의 나머지 부분과 첫 번째 부분을 “:” 문자로 구분한다.

대소문자는 구별하지 않기 때문에 [HTTP://와](HTTP://와) [http://는](http://는) 같다.

- 호스트:포트

애플리케이션이 인터넷에 있는 리소스를 찾으려면, 리소스를 호스팅하고 있는 장비와 그 장비 내에서 리소스에 접근할 수 있는 서버가 어디에 있는지 알아야한다.

URL의 호스트와 포트 컴포넌트가 두 가지의 정보를 제공한다.

호스트 컴포넌트는 접근하려고 하는 리소스를 가지고 있는 인터넷 상의 호스트 장비를 가리킨다.

즉 호스트의 값은 호스트명(”www.example.com”)이나 IP주소로 제공한다.

<aside>
💡 [http://**www.joes-hard](http://www.joes-hard)ware.com:80**/index.html → 호스트명으로 표현
http://**161.58.228.45:80**/index.html → IP주소로 표현

이 둘은 같은 리소스를 가리킨다.

</aside>

포트 컴포넌트는 서버가 열어놓은 네트워크 포트를 가리킨다.  HTTP는 기본 포트 80을 사용한다.

[포트(port) - 생활코딩](https://opentutorials.org/course/3265/20037)

- 사용자 이름과 비밀번호

서버가 자신이 가지고 있는 데이터의 접근을 허용하기 전에 사용자 이름과 비밀번호를 요구한다. 

예를 들면 FTP(파일 전송 프로토콜) 서버가 그렇다.

<aside>
💡 [ftp://ftp.prep.ai.mit.edu](ftp://ftp.prep.ai.mit.edu)/pub/gnu 

위의 스킴, 호스트, 경로만 있다. 위에서 말했듯 FTP는 사용자의 이름과 비밀번호를 요구한다.
하지만 사용자 이름과 비밀번호 컴포넌트는 보이지 않는다. 
FTP는 **사용자 이름과 비밀번호 컴포넌트가 없을 때는 기본값인 “anonymous”:”이메일 주소”를 자동으로 삽입**할 것이다.

비밀번호의 값은 기본적으로 “이메일 주소”가 들어가지만 브라우저마다 가지고 있는 기본값을 사용한다.
IE는 “IEUser”, 크롬은 “chrome@example.com”을 삽입한다.

크롬이라면 위의 예제는 아래처럼 기본값이 적용된다.

ftp://anonymous:chrome@example.com@ftp.prep.ai.mit.edu/pub/gnu

다시 위의 예제를 보면 <사용자 이름>:<비밀번호> 뒤에 “@”가 붙은 것을 볼 수 있다.
이것은 <사용자 이름>:<비밀번호> 컴포넌트와 다른 컴포넌트의 구분을 위해 존재한다.

그리고 사용자 이름과 비밀번호가 있다면 완성형은 결과는 아래처럼 표현된다.

ftp://joe:my_password@ftp.prep.ai.mit.edu/pub/gnu

</aside>

- 경로

경로 컴포넌트는 리소스가 서버의 어디에 있는지 알려준다.

형태은 **“계층적 파일 시스템 경로"**와 유사한 구조를 가진다. 

경로 컴포넌트는 “/” 문자를 기준으로 경로 조각으로 나뉜다.

<aside>
💡 [http://www.joes-hard](http://www.joes-hard)ware.com:80/seasonal/index-fall.html

경로를 보면 사이에 있는 “/”로 경로 조각으로 나뉜 것을 볼 수 있다. 이것은 “유닉스 파일 시스템”과 유사하다.
“계층적 파일 시스템 경로", “유닉스 파일 시스템” : **디렉토리 경로가 어떤 형태로 되어있는지 생각**하면 된다.

</aside>

- 파라미터

파라미터 컴포넌트는 애플리케이션이 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터를 받는데 사용한다.

형태는 **이름/값 쌍**의 리스트로 URL 나머지 부분들로부터 ‘;’ 문자로 구분하여 URL에 기술한다.

<aside>
💡 [ftp://prep.ai.mit](ftp://prep.ai.mit).edu/pub/gnu;type=d

보라색 텍스트인 “type=d”의 앞에 **“;”로 다른 컴포넌트와 구분이 되었고 “type”은 이름, “d”는 값이다.**

또한 바로 위의 경로 컴포넌트는 “/”를 통해 경로 조각을 나눌 수 있다고 언급했는데 그 경로 조각은 각각 파라미터 컴포넌트를 가질 수 있다.

http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=ture

파란색의 경로 컴포넌트가 “/”를 통해 두개의 경로 조각으로 나뉘면서 뒤의 “;”로 다른 컴포넌트와 구분된 “이름=값" 형태의  파라미터 컴포넌트를 확인할 수 있다.

</aside>

- 질의 문자열(쿼리)

DB 같은 서비스들은 요청받을 리소스 형식의 범위를 좁히기 위해 질문이나 질의를 받을 수 있다.

그것은 “질의 문자열"이라고 한다.

질의 문자열은 “?”의 우측에 있는 값들이다. 

<aside>
💡 [http://www.joes-hardware.com/inventory-check](http://www.joes-hardware.com/inventory-check).cgi?item=12731&color=blue&size=large

질의 문자열은 주로 “경로 컴포넌트"와 함께 전달하며 “?”를 통해 다른 컴포넌트와 구분한다.
또한 질의 문자열의 경우 복수로 입력할 수 있기 때문에 보통 **“&”로 구분**하여 **“이름=값” 형태**로 게이트웨이에 전달한다.

게이트웨이란 **다른 애플리케이션에 접근하려고 할 때 거치는 통로**이다.

*  cgi = common gateway interface, 서버가 데이터베이스에 질의를 내는 등 대화형 웹페이지를 작성할 때 이용
* 대화형 웹 = 사용자 조작에 맞춰 동적으로 변화하는 대화형 웹(Interactive Web)

</aside>

- 프래그먼트

HTML과 같은 리소스 형식들은 본래의 수준보다 더 작게 나뉠 수 있다. 

URL은 그 리소스에 대한 문서 전체를 가르치겠지만, 이상적으로는 리소스 안의 특정 요소를 가리킬 수 있어야 한다.

그때 사용되는 컴포넌트가 “프래그먼트”이다.

아래는 Velog의 게시물 우측에 위치하는 메뉴이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6638856d-cb9d-43b0-b1b9-c7c21d89582a/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e808edde-9912-42cd-a361-61bb54aff3b5/Untitled.png)

![메뉴를 클릭하지 않았을 때 URL](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/804e4840-2659-4fec-9af7-c4d65169b463/Untitled.png)

메뉴를 클릭하지 않았을 때 URL

![메뉴를 클릭하지 않았을 때 URL의 변화](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4bd168b8-e286-4642-b695-b49683654408/Untitled.png)

메뉴를 클릭하지 않았을 때 URL의 변화

<aside>
💡 클릭을 하지 않았을 때 “/HTMLCSS-Day12.-Text-속성”이라는 경로만 있었으나 클릭을 했을 때 그 바로 뒤에 “#”와 프래그먼트의 이름이 붙게 된다.

</aside>

일반적으로 HTTP 서버는 객체 일부가 아닌 전체만 다루기 때문에, 클라이언트는 서버에 프래그먼트를 전달하지 않는다.

**프래그먼트가 없는 URL을 받아 웹페이지를 전송한 후에 사용자가 보고자 하는 리소스의 일부를 보여준다.**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5a444771-82e8-4d0e-9c83-78c492fb065f/Untitled.png)

---

# 단축 URL

웹 클라이언트는 몇몇 “단축 URL”을 인식하고 사용한다.

많은 브라우저는 현재 사용자가 기억하고 있는 URL 일부를 입력하면 나머지 부분을 자동으로 입력해주는

URL “자동 확장"을 지원한다.

![주소표시줄에서 “w”만 입력할 경우 URL이 “자동 확장”된다. ](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1b39bbe0-b240-4bca-87ec-862bcea47cb0/Untitled.png)

주소표시줄에서 “w”만 입력할 경우 URL이 “자동 확장”된다. 

## 절대 URL VS 상대 URL

URL은 “상대 URL”과 “절대 URL”로 나뉜다.

절대 URL은 리소스에 접근하는데 필요한 모든 정보를 가지고 있다.

반면에 상대 URL은 절대 URL보다 URL을 짧게 표현하며 모든 정보를 담고 있지 않다.

상대 URL로 리소스에 접근하는데 필요한 모든 정보를 얻기 위해서는 “기저(base)”라고 하는 다른 URL을 사용해야한다.

<aside>
💡 나는 기저(base)를 “./”를 사용한 경로를 제외한 앞 부분으로 이해했다.

http://www.joes-hardware.com/hammers.html 에서 주황색의 부분은 “기저 URL”이라 부르고 전체를 “절대 URL"라 한다.
이를 ./hammers.html로 “기저 URL”대신 “./” 사용하여 대체해주면 “상대 URL”이라 한다.

</aside>

아래의 예제를 보면 `<a>태그` 에 있는 경로가 긴 URL과 다르게 생긴 것을 볼 수 있다.

아래의 URL은 미완성인 것처럼 보이지만 올바른 문법의 “상대 URL”이다.

상대 URL은 스킴(http)와 호스트(www.example.com) 그리고 다른 컴포넌트들을 모두 입력할 필요가 없다.

경로를 제외한 나머지는 “기저(base)”에서 알아낼 수 있다.

```html
<html>
	<head>
		<title>Joe's Tool</title>
	</head>
	<body>
		<h1>Tools Page</h1>
		<h2>Hammers</h2>
		<p>lorem ipsum ~~ <a href="./hammers.html">hammers</a></p>
	</body>
</html>

joes-hardware.com 웹 서버에서 /tool.html 리소스를 기준으로 상대경로로 명시되었다.
```

상대 URL은 “프래그먼트"거나 “URL의 일부"이다.

URL을 처리하는 브라우저 같은 **애플리케이션은 상대 URL과 절대 URL을 상호 변환을 할 수 있어야 한다.**

상대 URL을 사용하면 리소스 집합(HTML)을 쉽게 변경할 수 있다.

문서의 위치를 바꾸더라도 새로운 기저 URL로 인해 해석되기 때문이다.

<aside>
💡 기저 URL은 호스트 서버를 변경하지 않는 이상 변하지 않는다.

</aside>

## 상대 URL에서 절대 URL로 변환하는 과정

우선 상대 URL의 기준인 “기저 URL”을 먼저 찾아야한다. 이를 가져오는 몇 가지 방법들이 있다.

- **기저 URL을 리소스(HTML)에서 명시적으로 제공하는 경우**

: 리소스에 “기저 URL”을 명확히 기술하는 경우이다. HTML문서의 `<base>` 태그를 이용하면 문서 안의 모든 상대 URL을 기저 URL을 이용하여 변환할 수 있다.

- 리소스를 포함하고 있는 기저 URL

:  기저 URL을 명시하지 않은 경우, 리소스의 URL을 기저 URL로 사용할 수 있다.

- 기저 URL이 없는 경우

:  모두 절대 URL만으로 이루어져 있다는 뜻이다. 이는 불완전하거나 깨진 URL일 수 있다.

- 상대 참조 해석하기

:  기저 URL과 상대 URL은 절대 URL로 변환하기 위해 “URL 분해”를 하는데 이 과정을 끝내면 알고리즘을 사용하여 절대 URL로 변환한다.

## URL 확장

어떤 브라우저들은 URL을 입력한 다음이나 입력하고 있는 동안에 자동으로 URL을 확장한다.

이것은 사용자가 URL을 빠르게 입력할 수 있게 도와준다.

확장 기능은 두 가지로 나뉜다.

- 호스트명 확장 : 단순한 휴리스틱(*경험적 지식에 의존하는 것)만을 사용해서 입력한 호스트 명을 전체 호스트 명으로 확장할 수 있다.

<aside>
💡 예를 들면, yahoo를 입력했는데 “www.”와 “.com”가 자동으로 붙어서 “www.yahoo.com”을 만드는 것이다. 만약 “yahoo”라는 단어를 포함한 
사이트를 찾지 못하면 확장을 포기하기 전에 몇 가지의 URL을 추가로 제시한다.

</aside>

- **히스토리** 확장 :  **사용자가 방문했던 URL을 저장**해놓고 입력된 URL의 앞 글자를 포함한 완결된 URL을 선택하게 한다.

---

# URL 인코딩과 문자 규칙

URL은 상대적으로 **작고** 일반적으로 **안전한 알파벳 문자**만 포함하도록 허락된다.

컴퓨터 시스템의 기본 문자는 영어 중심이다. 

그래서 역사적으로 가장 `US-ASCII` 문자 집합을 많이 사용해왔다.  

`US-ASCII`는 문자를 서식화하고 하드웨어상에서 신호를 주고받기 위해 “7비트"를 사용하여 영문 자판에 있는 키 대부분과 몇몇 출력되지 않는 제어 문자를 표현한다.

하지만, `US-ASCII`는 오래된 문자 집합이라 적은 수의 문자만 포함하고 있다.

미국 시민들 사이에서는 편리하게 쓰이지만 종류가 많은 유럽 언어와 비 라틴계 언어들에 존재하는 변형 문자는 지원하지 않는다.

그리고 이진 데이터를 포함해야 하는 경우도 있다.

이를 위해 `US-ASCII`에서 사용 금지 문자인 이스케이프 문자열을 특정문자나 데이터를 인코딩할 수 있게 함으로써 이동성과 완성도를 높였다.

그래서 인코딩은 안전하지 않은 문자를 %로 시작해, ASCII 코드로 표현되는 두 개의 16진수 숫자로 이루어진 ‘이스케이프’ 문자로 바꾼다.

몇몇 문자는 URL에서 **특별한 의미로 선점(예약)이 되어 있어 사용할 수 없다.**

# 웹에서 쓰이는 일반 URL 스킴

- **http** : 사용자 이름이나 비밀번호가 없다는 것을 제외하고는 일반 URL의 형태를 지키는 스킴이다. 포트값 생략 시 기본 포트는 80이다.

```markdown
http://<호스트>:<포트>/<경로>?<질의>#<프래그먼트>
```

- **https** : http 스킴과 거의 같다.  HTTP의 양 끝단에서 **암호화**하기 위해 `SSL`(Secure Sockets Layer, [암호화](https://www.cloudflare.com/learning/ssl/what-is-encryption/)
 기반 인터넷 보안 [프로토콜](https://www.cloudflare.com/learning/network-layer/what-is-a-protocol/))을 사용한다.

[](https://www.cloudflare.com/ko-kr/learning/ssl/what-is-ssl/)

SSL이란?

```markdown
<!-- 형태는 http와 다른 것이 없다. -->
https://<호스트>:<포트>/<경로>?<질의>#<프래그먼트>
```

- mailto : mailto URL은 이메일 주소를 가리킨다. 다른 스킴과는 다르게 동작하기 때문에 표준 URL과 다른 형태를 가진다.

```markdown
mailto:<이메일>
```

- ftp : 파일 전송 프로토콜(File Transfer Protocol) URL은 서버의 파일을 다운로드나 업로드하고 FTP 서버의 디렉토리에 있는 콘텐츠 목록을 가져오는데 사용할 수 있다.

```markdown
ftp://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>
```

- rtsp, rtspu : **실시간 스트리밍 프로토콜(Real Time Streaming Protocol)**을 통해 읽을 수 있는 오디오 및 비디오와 같은 미디어 리소스 식별자이다.

rtspu의 “u”는 UDP 프로토콜(데이터를 주고받을 때 연결 절차를 거치지 않고 발신자가 일방적으로 데이터를 발신하는 방식)이 사용됨을 뜻한다.

```markdown
rtsp://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>
rtspu://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>
```

- file : file스킴은 주어진 호스트 기기에서 바로 접근할 수 있는 파일들을 나타낸다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cd549da3-e2da-4d3f-b52e-bb759491e85d/Untitled.png)

```markdown
file://<호스트>:<경로>

호스트 서버가 생략되어 있으면 URL을 사용하고 있는 기기의 로컬 호스트가 기본값이 된다.
```

- news : 특정 문서나 뉴스 그룹에 접근하는데 사용된다.

- telnet : telnet 스킴은 대화형 서비스에 접근하는데 사용한다.

# URN을 포함한 URL의 미래

URL은 세상의 모든 객체에 이름을 지을 수 있고 새로운 포맷을 쉽게 추가할 수도 있어 강력한 도구임이 확실하다.

URL은 특정 시점에 어떤 것이 위치한 곳을 알려주는 것을 의미한다. 여기서 URL은 필요한 포트와 서버 이름을 제공한다.

하지만 URL의 스킴의 단점은 리소스가 옮겨지면 URL을 사용할 수 없다는 것이다. 즉, 그 객체를 찾을 수가 없다는 의미이다.

그래서 이런 단점을 보완하기 위한 “URN(Uniform Resource Name)”이라는 것을 표준으로 하기 위해 작업에 착수하였다.

URN은 객체의 위치와 상관없이 그 객체를 가리키는 **실제 객체의 이름**을 사용하는 것이다. 

이 말은 즉슨, 객체가 옮겨지더라고 객체의 이름만 알면 옮겨지더라고 항상 객체를 찾을 수 있다.

### 하지만 URN 방식을 채택되지 못했다.

URL에서 URN으로 주소 체계를 바꾸는 것은 매우 큰 작업이다.

표준을 제정과 여러 HTTP 애플리케이션 수정하기 위한 벤더들과의 합의가 필요하기 때문이다.
